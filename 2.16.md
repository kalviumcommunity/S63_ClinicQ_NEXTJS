Transaction & Query Optimisation

In this concept, you’ll learn how to implement database transactions, use indexes, and apply query optimisation techniques in your Prisma ORM-based backend to improve performance and maintain data integrity. These practices help ensure your application remains consistent, reliable, and performant as your data scales.

Note: These are general guidelines — you may customise your models, transaction logic, and optimization strategy based on your project’s problem statement and data requirements.

What You’ll Do
1. Understand Transactions
A transaction ensures that multiple database operations either all succeed or all fail — maintaining atomicity and consistency.

For example, when placing an order:

Create the order
Update product inventory
Record the payment All three must succeed together.
Use Prisma’s $transaction() API:

const [order, inventory] = await prisma.$transaction([
  prisma.order.create({ data: { userId, amount } }),
  prisma.product.update({
    where: { id: productId },
    data: { stock: { decrement: 1 } },
  }),
]);
console.log('Transaction successful:', order, inventory);
If one operation fails, Prisma automatically rolls back the changes.

2. Implement Transaction Rollbacks and Error Handling
Wrap your transactions in try-catch blocks to handle errors gracefully:

try {
  await prisma.$transaction(async (tx) => {
    const user = await tx.user.create({ data: { name: 'Alice' } });
    await tx.order.create({
      data: { userId: user.id, total: 500 },
    });
  });
} catch (error) {
  console.error('Transaction failed. Rolling back.', error);
}
Verify rollback behavior by intentionally triggering an error (e.g., invalid data) and confirming that no partial writes occurred in the database.

3. Optimize Queries for Performance
Avoid over-fetching: Only select fields you need.

// Inefficient
const users = await prisma.user.findMany({ include: { posts: true, orders: true } });

// Optimized
const users = await prisma.user.findMany({
  select: { id: true, name: true, email: true },
});
Batch operations when possible:

await prisma.user.createMany({
  data: [
    { name: 'Alice' },
    { name: 'Bob' },
    { name: 'Charlie' },
  ],
});
Paginate results using skip and take:

const users = await prisma.user.findMany({
  skip: 0,
  take: 10,
  orderBy: { createdAt: 'desc' },
});
4. Add Indexes to Improve Query Speed
In your schema.prisma, add indexes for frequently queried fields:

model Order {
  id        Int     @id @default(autoincrement())
  userId    Int
  status    String
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([status])
}
After updating the schema, run:

npx prisma migrate dev --name add_indexes
This creates new migration files and applies the index changes to your database.

5. Monitor and Benchmark Query Performance
Enable Prisma query logs:

DEBUG="prisma:query" npm run dev
Use SQL EXPLAIN or Prisma logging to compare before/after performance:

Before adding indexes
After adding indexes Note time differences and execution patterns.
Optionally, use tools like:

PgHero or Prisma Studio for query visualization
AWS RDS Performance Insights or Azure Query Performance for deeper analysis
6. Document in README
Your README should clearly describe:

Transaction Scenarios — where and why you used them
Rollback Logic — how you ensured atomicity
Indexes Added — and which queries they optimize
Performance Comparison — include logs or metrics before and after optimization
Anti-patterns Avoided — e.g., N+1 queries, full table scans
Reflection — how you would monitor queries in production (latency, error rates)
Include screenshots, terminal logs, or time comparisons to evidence your work.

Deliverables
Working Prisma code demonstrating at least one transaction and rollback
Updated schema.prisma with indexes for optimized queries
Before/after logs showing query performance improvement
Detailed README documenting your workflow, findings, and reflection
Pro Tip: Use transactions when data operations depend on each other. Use indexes when queries are repeated or slow. Together, they make your database faster, safer, and more professional.

Resources
Prisma ORM: Working with Transactions
Prisma ORM: Indexes and Constraints in Prisma Schema
PostgreSQL Docs: Understanding Indexes and Performance