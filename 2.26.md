Page Routing and Dynamic Routes

In this lesson, youâ€™ll learn how to implement page routing and dynamic routes using the Next.js App Router. Routing is at the heart of every web application â€” it determines how users move between pages and how data is loaded for each view. Youâ€™ll build public and protected pages, handle dynamic parameters, and reflect on SEO, breadcrumbs, and error handling for a complete routing experience.

By the end of this lesson, youâ€™ll have a working route structure with public, protected, and dynamic pages â€” all powered by Next.js 13+ App Router conventions.

1. Understanding Routing in Next.js App Router
The App Router in Next.js uses a file-based routing system. Each folder inside the app/ directory represents a route.

Example structure:

app/
 â”œâ”€â”€ page.tsx               â†’ Home (public)
 â”œâ”€â”€ login/
 â”‚    â””â”€â”€ page.tsx          â†’ Login page (public)
 â”œâ”€â”€ dashboard/
 â”‚    â””â”€â”€ page.tsx          â†’ Protected route
 â”œâ”€â”€ users/
 â”‚    â”œâ”€â”€ page.tsx          â†’ List users
 â”‚    â””â”€â”€ [id]/
 â”‚         â””â”€â”€ page.tsx     â†’ Dynamic route for each user
 â”œâ”€â”€ not-found.tsx          â†’ Custom 404 page
 â””â”€â”€ layout.tsx             â†’ Global layout wrapper
Key Concept:

page.tsx â†’ defines a page route.
[id]/page.tsx â†’ defines a dynamic route where id can be any value.
layout.tsx â†’ wraps shared UI like navigation bars or footers.
2. Setting Up Public and Protected Routes
Youâ€™ll implement a simple auth middleware that restricts access to protected pages like /dashboard.

middleware.ts
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";
import jwt from "jsonwebtoken";

const JWT_SECRET = process.env.JWT_SECRET || "supersecretkey";

export function middleware(req: NextRequest) {
  const { pathname } = req.nextUrl;

  // Public routes
  if (pathname.startsWith("/login") || pathname === "/") {
    return NextResponse.next();
  }

  // Protected routes
  if (pathname.startsWith("/dashboard") || pathname.startsWith("/users")) {
    const token = req.cookies.get("token")?.value;

    if (!token) {
      const loginUrl = new URL("/login", req.url);
      return NextResponse.redirect(loginUrl);
    }

    try {
      jwt.verify(token, JWT_SECRET);
      return NextResponse.next();
    } catch {
      const loginUrl = new URL("/login", req.url);
      return NextResponse.redirect(loginUrl);
    }
  }

  return NextResponse.next();
}

export const config = {
  matcher: ["/dashboard/:path*", "/users/:path*"],
};
Key Idea:

Public routes can be accessed by anyone.
Protected routes require a valid JWT stored in cookies.
3. Creating Public Pages
app/page.tsx (Home Page)
export default function Home() {
  return (
    <main className="flex flex-col items-center mt-10">
      <h1 className="text-2xl font-bold">Welcome to the App ğŸš€</h1>
      <p>Navigate to /login to sign in or /dashboard after login.</p>
    </main>
  );
}
app/login/page.tsx
"use client";
import { useRouter } from "next/navigation";
import Cookies from "js-cookie";

export default function Login() {
  const router = useRouter();

  function handleLogin() {
    // Mock token (in real apps, get it from backend)
    Cookies.set("token", "mock.jwt.token");
    router.push("/dashboard");
  }

  return (
    <main className="flex flex-col items-center mt-10">
      <h1 className="text-xl font-semibold">Login Page</h1>
      <button
        onClick={handleLogin}
        className="bg-blue-600 text-white px-4 py-2 mt-4 rounded"
      >
        Login
      </button>
    </main>
  );
}
4. Creating a Protected Page
app/dashboard/page.tsx
export default function Dashboard() {
  return (
    <main className="flex flex-col items-center mt-10">
      <h1 className="text-2xl font-bold">Dashboard</h1>
      <p>Only logged-in users can see this page.</p>
    </main>
  );
}
5. Implementing Dynamic Routes
Dynamic routes let you load content based on parameters (like /users/1 or /users/42).

app/users/[id]/page.tsx
interface Props {
  params: { id: string };
}

export default async function UserProfile({ params }: Props) {
  const { id } = params;
  // Mock fetch user data
  const user = { id, name: "User " + id };

  return (
    <main className="flex flex-col items-center mt-10">
      <h2 className="text-xl font-bold">User Profile</h2>
      <p>ID: {user.id}</p>
      <p>Name: {user.name}</p>
    </main>
  );
}
Try visiting: /users/1, /users/2, etc. â€” each will render a different page dynamically.

6. Adding Navigation and Layout
app/layout.tsx
import Link from "next/link";

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <nav className="flex gap-4 p-4 bg-gray-100">
          <Link href="/">Home</Link>
          <Link href="/login">Login</Link>
          <Link href="/dashboard">Dashboard</Link>
          <Link href="/users/1">User 1</Link>
        </nav>
        {children}
      </body>
    </html>
  );
}
Tip: Include breadcrumbs in dynamic routes like /users/[id] to improve navigation and SEO.

7. Handling 404 and Error States
Create a custom 404 page:

app/not-found.tsx
export default function NotFound() {
  return (
    <main className="flex flex-col items-center mt-10 text-red-600">
      <h1 className="text-2xl font-bold">404 â€” Page Not Found</h1>
      <p>Oops! This route doesnâ€™t exist.</p>
    </main>
  );
}
8. Reflect and Document in README
Your README.md should include:

A route map with clear distinction between:

Public routes: /, /login
Protected routes: /dashboard, /users/[id]
Code snippets showing route definitions and middleware.

Screenshots of:

Public vs protected route access.
Dynamic user pages (/users/1, /users/2).
Navigation bar and breadcrumbs.
Custom 404 page.
Reflection on:

How dynamic routing supports scalability and SEO.
How breadcrumbs and structured routes improve user experience.
Handling error states gracefully.
Deliverables
Working public and protected route setup with middleware.

Dynamic routes that render parameterized content.

Custom 404 error page and layout navigation.

README including:

Route map visualization.
Screenshots and behavior proofs.
Reflection on SEO and routing best practices.
Pro Tip: â€œGreat routing design is invisible â€” users just feel like everything connects seamlessly.â€

