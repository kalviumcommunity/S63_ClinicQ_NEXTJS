Layout and Component Architecture

In this lesson, you’ll learn how to design a reusable component architecture in your Next.js application — building modular UI elements like Header, Sidebar, and Layout wrappers that ensure consistent design, maintainability, and scalability across pages.

By the end of this lesson, you’ll have a structured component hierarchy, shared layout templates, and a documented design approach that supports reusability, accessibility, and visual uniformity across your app.

1. Why Component Architecture Matters
A well-structured component architecture helps ensure:

Benefit	Description
Reusability	Common UI pieces (e.g., buttons, navbars) can be used across pages.
Maintainability	Updating one component updates the entire UI consistently.
Scalability	Clear structure allows easier onboarding and expansion.
Accessibility	Shared components can standardize ARIA roles and keyboard interactions.
2. Recommended Folder Structure
Organize your UI components for modularity and reuse.

app/
 ├── layout.tsx              → Global layout wrapper
 ├── page.tsx                → Home page
 ├── dashboard/
 │    └── page.tsx           → Uses shared layout and components
 components/
 ├── layout/
 │    ├── Header.tsx
 │    ├── Sidebar.tsx
 │    ├── LayoutWrapper.tsx
 ├── ui/
 │    ├── Button.tsx
 │    ├── Card.tsx
 │    └── InputField.tsx
 └── index.ts                → Barrel export for all components
 styles/
 └── globals.css
Tip: Use barrel exports (index.ts) to simplify imports:

export { default as Header } from "./layout/Header";
export { default as Sidebar } from "./layout/Sidebar";
export { default as LayoutWrapper } from "./layout/LayoutWrapper";
3. Building a Reusable Header Component
components/layout/Header.tsx
"use client";
import Link from "next/link";

export default function Header() {
  return (
    <header className="w-full bg-blue-600 text-white px-6 py-3 flex justify-between items-center">
      <h1 className="font-semibold text-lg">MyApp</h1>
      <nav className="flex gap-4">
        <Link href="/">Home</Link>
        <Link href="/dashboard">Dashboard</Link>
        <Link href="/profile">Profile</Link>
      </nav>
    </header>
  );
}
Key Idea: The Header is a shared navigation component with responsive design and consistent colors.

4. Creating a Sidebar Component
components/layout/Sidebar.tsx
"use client";
import Link from "next/link";

export default function Sidebar() {
  const links = [
    { href: "/dashboard", label: "Overview" },
    { href: "/users", label: "Users" },
    { href: "/settings", label: "Settings" },
  ];

  return (
    <aside className="w-64 h-screen bg-gray-100 border-r p-4">
      <h2 className="text-lg font-bold mb-4">Navigation</h2>
      <ul className="space-y-2">
        {links.map(link => (
          <li key={link.href}>
            <Link href={link.href} className="text-gray-700 hover:text-blue-600">
              {link.label}
            </Link>
          </li>
        ))}
      </ul>
    </aside>
  );
}
Key Idea: The Sidebar manages contextual navigation and uses reusable link data for scalability.

5. Defining a Layout Wrapper
components/layout/LayoutWrapper.tsx
import Header from "./Header";
import Sidebar from "./Sidebar";

export default function LayoutWrapper({ children }: { children: React.ReactNode }) {
  return (
    <div className="flex flex-col h-screen">
      <Header />
      <div className="flex flex-1">
        <Sidebar />
        <main className="flex-1 bg-white p-6 overflow-auto">{children}</main>
      </div>
    </div>
  );
}
Key Idea: The LayoutWrapper serves as the foundation for all pages — ensuring every route shares consistent navigation, layout spacing, and colors.

6. Applying Layout to Pages
app/layout.tsx
import "./globals.css";
import { LayoutWrapper } from "@/components";

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <LayoutWrapper>{children}</LayoutWrapper>
      </body>
    </html>
  );
}
Behavior: All pages (/, /dashboard, /users) will automatically include the Header and Sidebar.

7. Reusable UI Elements (Example: Button)
components/ui/Button.tsx
interface ButtonProps {
  label: string;
  onClick?: () => void;
  variant?: "primary" | "secondary";
}

export default function Button({ label, onClick, variant = "primary" }: ButtonProps) {
  const styles =
    variant === "primary"
      ? "bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700"
      : "bg-gray-200 text-gray-700 px-4 py-2 rounded hover:bg-gray-300";

  return (
    <button onClick={onClick} className={styles}>
      {label}
    </button>
  );
}
Props Contract: Reusable components should accept configurable props for flexibility and accessibility.

8. (Optional) Visual Testing with Storybook
You can use Storybook (or a similar tool) to preview and document your components.

npx storybook init
Then create a story for your component:

components/ui/Button.stories.tsx
import Button from "./Button";

export default {
  title: "UI/Button",
  component: Button,
};

export const Primary = () => <Button label="Click Me" />;
export const Secondary = () => <Button label="Cancel" variant="secondary" />;
Key Benefit: Storybook captures reusable component variations and helps maintain visual consistency.

9. Reflect and Document in README
Your README.md should include:

A component hierarchy diagram (Header → Sidebar → LayoutWrapper → Page).

Code snippets for reusable components (Header, Sidebar, LayoutWrapper, Button).

Screenshots of:

The full layout with header/sidebar visible.
Storybook (or equivalent) showing components in isolation.
Explanation of:

Props contracts and how components communicate.
How shared components maintain design consistency.
Accessibility considerations (keyboard nav, ARIA roles, color contrast).
Reflection on:

Benefits of modular architecture in scaling large apps.
How visual consistency improves UX and developer productivity.
Deliverables
Modular components: Header, Sidebar, LayoutWrapper, and at least one UI element (e.g., Button).

Working page layout using the new architecture.

Storybook (or screenshot-based equivalent) showing components in isolation.

README with:

Component hierarchy documentation.
Props and usage examples.
Reflection on reusability, accessibility, and consistency.
Pro Tip: “Good UI architecture is invisible — the user just experiences clarity and flow, while the developer experiences joy and reusability.”

