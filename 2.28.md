State Management using Context & Hooks

In this lesson, you’ll learn how to implement global state management in your Next.js application using React Context API and custom hooks. Global state allows different parts of your app — like authentication, UI themes, or notifications — to share and synchronize data efficiently without prop-drilling.

By the end of this lesson, you’ll have created reusable contexts (e.g., AuthContext, UIContext) and custom hooks (useAuth, useUI) to handle shared logic and improve maintainability.

1. Why Use Context and Hooks?
Concept	Purpose	Example
Context	Provides a way to pass data through the component tree without props.	Share logged-in user data across pages.
Custom Hook	Encapsulates reusable logic for cleaner components.	useAuth() handles login, logout, and state access.
Reducer (optional)	Manages complex state transitions predictably.	Handle UI theme toggling with action types.
Key Idea: Context centralizes data, while custom hooks provide an elegant interface to use it anywhere.

2. Folder Structure
app/
 ├── layout.tsx
 ├── page.tsx
context/
 ├── AuthContext.tsx
 ├── UIContext.tsx
hooks/
 ├── useAuth.ts
 ├── useUI.ts
3. Creating an AuthContext
context/AuthContext.tsx
"use client";
import { createContext, useState, useContext, ReactNode } from "react";

interface AuthContextType {
  user: string | null;
  login: (username: string) => void;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<string | null>(null);

  const login = (username: string) => {
    setUser(username);
    console.log("User logged in:", username);
  };

  const logout = () => {
    setUser(null);
    console.log("User logged out");
  };

  return (
    <AuthContext.Provider value={{ user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

// Custom hook for consuming context
export function useAuthContext() {
  const context = useContext(AuthContext);
  if (!context) throw new Error("useAuthContext must be used within an AuthProvider");
  return context;
}
Key Idea: The AuthProvider wraps your app and makes authentication state available to any component.

4. Creating a UIContext (for Theme or Sidebar)
context/UIContext.tsx
"use client";
import { createContext, useContext, useState, ReactNode } from "react";

interface UIContextType {
  theme: "light" | "dark";
  toggleTheme: () => void;
  sidebarOpen: boolean;
  toggleSidebar: () => void;
}

const UIContext = createContext<UIContextType | undefined>(undefined);

export function UIProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState<"light" | "dark">("light");
  const [sidebarOpen, setSidebarOpen] = useState(false);

  const toggleTheme = () => setTheme((prev) => (prev === "light" ? "dark" : "light"));
  const toggleSidebar = () => setSidebarOpen((prev) => !prev);

  return (
    <UIContext.Provider value={{ theme, toggleTheme, sidebarOpen, toggleSidebar }}>
      {children}
    </UIContext.Provider>
  );
}

export function useUIContext() {
  const context = useContext(UIContext);
  if (!context) throw new Error("useUIContext must be used within a UIProvider");
  return context;
}
Key Idea: UIContext stores and updates the theme and sidebar visibility for consistent user experience across routes.

5. Using Both Providers Globally
app/layout.tsx
import { AuthProvider } from "@/context/AuthContext";
import { UIProvider } from "@/context/UIContext";
import "./globals.css";

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <AuthProvider>
          <UIProvider>
            {children}
          </UIProvider>
        </AuthProvider>
      </body>
    </html>
  );
}
Behavior: Now both contexts are globally available — any component can access authentication and UI state directly.

6. Consuming Context via Custom Hooks
hooks/useAuth.ts
import { useAuthContext } from "@/context/AuthContext";

export function useAuth() {
  const { user, login, logout } = useAuthContext();

  return {
    isAuthenticated: !!user,
    user,
    login,
    logout,
  };
}
hooks/useUI.ts
import { useUIContext } from "@/context/UIContext";

export function useUI() {
  const { theme, toggleTheme, sidebarOpen, toggleSidebar } = useUIContext();

  return {
    theme,
    toggleTheme,
    sidebarOpen,
    toggleSidebar,
  };
}
Key Idea: These custom hooks abstract internal logic, keeping components simple and declarative.

7. Example Usage
app/page.tsx
"use client";
import { useAuth } from "@/hooks/useAuth";
import { useUI } from "@/hooks/useUI";

export default function Home() {
  const { user, login, logout, isAuthenticated } = useAuth();
  const { theme, toggleTheme, sidebarOpen, toggleSidebar } = useUI();

  return (
    <main className={`p-6 ${theme === "dark" ? "bg-gray-900 text-white" : "bg-white text-black"}`}>
      <h1 className="text-2xl font-bold mb-4">Context & Hooks Demo</h1>

      <section className="mb-6">
        <h2 className="font-semibold mb-2">Auth State</h2>
        {isAuthenticated ? (
          <>
            <p>Logged in as: {user}</p>
            <button onClick={logout} className="bg-red-500 text-white px-3 py-1 rounded">Logout</button>
          </>
        ) : (
          <button onClick={() => login("KalviumUser")} className="bg-green-500 text-white px-3 py-1 rounded">Login</button>
        )}
      </section>

      <section>
        <h2 className="font-semibold mb-2">UI Controls</h2>
        <p>Current Theme: {theme}</p>
        <button onClick={toggleTheme} className="bg-blue-500 text-white px-3 py-1 rounded mr-3">Toggle Theme</button>
        <button onClick={toggleSidebar} className="bg-yellow-500 text-black px-3 py-1 rounded">
          {sidebarOpen ? "Close Sidebar" : "Open Sidebar"}
        </button>
      </section>
    </main>
  );
}
Console Output Example:

User logged in: KalviumUser
Sidebar opened
Theme toggled to dark
8. Debugging & Performance
Use React DevTools → “Components” tab → Inspect Context Provider values.
Wrap context consumers in React.memo() if they re-render frequently.
For heavy state transitions, consider useReducer() with dispatch pattern.
Example:

const [state, dispatch] = useReducer(reducer, initialState);
9. Reflect and Document in README
Your README.md should include:

Explanation of:

The purpose of each context (Auth, UI).
How custom hooks encapsulate shared logic.
Reducer logic (if implemented) and state flow.
Code snippets and structure diagram.

Screenshots or console logs showing state transitions (e.g., login/logout/theme toggle).

Reflection on:

Performance strategies (memoization, reducers).
How context improves scalability and code readability.
Potential pitfalls (unnecessary re-renders).
Deliverables
Working global context setup (AuthContext, UIContext).

At least one custom hook per context.

Demonstrated state changes (login/logout, theme toggle).

README containing:

Code structure, state flow, and props.
Evidence (logs/screenshots).
Reflection on performance and reusability.
Pro Tip: “Context + Hooks = maintainable, scalable state. Keep logic shared, components light, and re-renders minimal.”

